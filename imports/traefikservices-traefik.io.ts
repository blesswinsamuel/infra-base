// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * TraefikService is the CRD implementation of a Traefik Service. TraefikService object allows to: - Apply weight to Services on load-balancing - Mirror traffic on services More info: https://doc.traefik.io/traefik/v2.10/routing/providers/kubernetes-crd/#kind-traefikservice
 *
 * @schema TraefikService
 */
export class TraefikService extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TraefikService"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'traefik.io/v1alpha1',
    kind: 'TraefikService',
  }

  /**
   * Renders a Kubernetes manifest for "TraefikService".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TraefikServiceProps): any {
    return {
      ...TraefikService.GVK,
      ...toJson_TraefikServiceProps(props),
    };
  }

  /**
   * Defines a "TraefikService" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TraefikServiceProps) {
    super(scope, id, {
      ...TraefikService.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TraefikService.GVK,
      ...toJson_TraefikServiceProps(resolved),
    };
  }
}

/**
 * TraefikService is the CRD implementation of a Traefik Service. TraefikService object allows to: - Apply weight to Services on load-balancing - Mirror traffic on services More info: https://doc.traefik.io/traefik/v2.10/routing/providers/kubernetes-crd/#kind-traefikservice
 *
 * @schema TraefikService
 */
export interface TraefikServiceProps {
  /**
   * @schema TraefikService#metadata
   */
  readonly metadata: ApiObjectMetadata;

  /**
   * TraefikServiceSpec defines the desired state of a TraefikService.
   *
   * @schema TraefikService#spec
   */
  readonly spec: TraefikServiceSpec;

}

/**
 * Converts an object of type 'TraefikServiceProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceProps(obj: TraefikServiceProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TraefikServiceSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TraefikServiceSpec defines the desired state of a TraefikService.
 *
 * @schema TraefikServiceSpec
 */
export interface TraefikServiceSpec {
  /**
   * Mirroring defines the Mirroring service configuration.
   *
   * @schema TraefikServiceSpec#mirroring
   */
  readonly mirroring?: TraefikServiceSpecMirroring;

  /**
   * Weighted defines the Weighted Round Robin configuration.
   *
   * @schema TraefikServiceSpec#weighted
   */
  readonly weighted?: TraefikServiceSpecWeighted;

}

/**
 * Converts an object of type 'TraefikServiceSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpec(obj: TraefikServiceSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mirroring': toJson_TraefikServiceSpecMirroring(obj.mirroring),
    'weighted': toJson_TraefikServiceSpecWeighted(obj.weighted),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mirroring defines the Mirroring service configuration.
 *
 * @schema TraefikServiceSpecMirroring
 */
export interface TraefikServiceSpecMirroring {
  /**
   * Kind defines the kind of the Service.
   *
   * @schema TraefikServiceSpecMirroring#kind
   */
  readonly kind?: TraefikServiceSpecMirroringKind;

  /**
   * MaxBodySize defines the maximum size allowed for the body of the request. If the body is larger, the request is not mirrored. Default value is -1, which means unlimited size.
   *
   * @schema TraefikServiceSpecMirroring#maxBodySize
   */
  readonly maxBodySize?: number;

  /**
   * Mirrors defines the list of mirrors where Traefik will duplicate the traffic.
   *
   * @schema TraefikServiceSpecMirroring#mirrors
   */
  readonly mirrors?: TraefikServiceSpecMirroringMirrors[];

  /**
   * Name defines the name of the referenced Kubernetes Service or TraefikService. The differentiation between the two is specified in the Kind field.
   *
   * @schema TraefikServiceSpecMirroring#name
   */
  readonly name: string;

  /**
   * Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
   *
   * @schema TraefikServiceSpecMirroring#namespace
   */
  readonly namespace?: string;

  /**
   * NativeLB controls, when creating the load-balancer, whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP. The Kubernetes Service itself does load-balance to the pods. By default, NativeLB is false.
   *
   * @schema TraefikServiceSpecMirroring#nativeLB
   */
  readonly nativeLb?: boolean;

  /**
   * PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service. By default, passHostHeader is true.
   *
   * @schema TraefikServiceSpecMirroring#passHostHeader
   */
  readonly passHostHeader?: boolean;

  /**
   * Port defines the port of a Kubernetes Service. This can be a reference to a named port.
   *
   * @schema TraefikServiceSpecMirroring#port
   */
  readonly port?: TraefikServiceSpecMirroringPort;

  /**
   * ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
   *
   * @schema TraefikServiceSpecMirroring#responseForwarding
   */
  readonly responseForwarding?: TraefikServiceSpecMirroringResponseForwarding;

  /**
   * Scheme defines the scheme to use for the request to the upstream Kubernetes Service. It defaults to https when Kubernetes Service port is 443, http otherwise.
   *
   * @schema TraefikServiceSpecMirroring#scheme
   */
  readonly scheme?: string;

  /**
   * ServersTransport defines the name of ServersTransport resource to use. It allows to configure the transport between Traefik and your servers. Can only be used on a Kubernetes Service.
   *
   * @schema TraefikServiceSpecMirroring#serversTransport
   */
  readonly serversTransport?: string;

  /**
   * Sticky defines the sticky sessions configuration. More info: https://doc.traefik.io/traefik/v2.10/routing/services/#sticky-sessions
   *
   * @schema TraefikServiceSpecMirroring#sticky
   */
  readonly sticky?: TraefikServiceSpecMirroringSticky;

  /**
   * Strategy defines the load balancing strategy between the servers. RoundRobin is the only supported value at the moment.
   *
   * @schema TraefikServiceSpecMirroring#strategy
   */
  readonly strategy?: string;

  /**
   * Weight defines the weight and should only be specified when Name references a TraefikService object (and to be precise, one that embeds a Weighted Round Robin).
   *
   * @schema TraefikServiceSpecMirroring#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'TraefikServiceSpecMirroring' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecMirroring(obj: TraefikServiceSpecMirroring | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'maxBodySize': obj.maxBodySize,
    'mirrors': obj.mirrors?.map(y => toJson_TraefikServiceSpecMirroringMirrors(y)),
    'name': obj.name,
    'namespace': obj.namespace,
    'nativeLB': obj.nativeLb,
    'passHostHeader': obj.passHostHeader,
    'port': obj.port?.value,
    'responseForwarding': toJson_TraefikServiceSpecMirroringResponseForwarding(obj.responseForwarding),
    'scheme': obj.scheme,
    'serversTransport': obj.serversTransport,
    'sticky': toJson_TraefikServiceSpecMirroringSticky(obj.sticky),
    'strategy': obj.strategy,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Weighted defines the Weighted Round Robin configuration.
 *
 * @schema TraefikServiceSpecWeighted
 */
export interface TraefikServiceSpecWeighted {
  /**
   * Services defines the list of Kubernetes Service and/or TraefikService to load-balance, with weight.
   *
   * @schema TraefikServiceSpecWeighted#services
   */
  readonly services?: TraefikServiceSpecWeightedServices[];

  /**
   * Sticky defines whether sticky sessions are enabled. More info: https://doc.traefik.io/traefik/v2.10/routing/providers/kubernetes-crd/#stickiness-and-load-balancing
   *
   * @schema TraefikServiceSpecWeighted#sticky
   */
  readonly sticky?: TraefikServiceSpecWeightedSticky;

}

/**
 * Converts an object of type 'TraefikServiceSpecWeighted' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecWeighted(obj: TraefikServiceSpecWeighted | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'services': obj.services?.map(y => toJson_TraefikServiceSpecWeightedServices(y)),
    'sticky': toJson_TraefikServiceSpecWeightedSticky(obj.sticky),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kind defines the kind of the Service.
 *
 * @schema TraefikServiceSpecMirroringKind
 */
export enum TraefikServiceSpecMirroringKind {
  /** Service */
  SERVICE = "Service",
  /** TraefikService */
  TRAEFIK_SERVICE = "TraefikService",
}

/**
 * MirrorService holds the mirror configuration.
 *
 * @schema TraefikServiceSpecMirroringMirrors
 */
export interface TraefikServiceSpecMirroringMirrors {
  /**
   * Kind defines the kind of the Service.
   *
   * @schema TraefikServiceSpecMirroringMirrors#kind
   */
  readonly kind?: TraefikServiceSpecMirroringMirrorsKind;

  /**
   * Name defines the name of the referenced Kubernetes Service or TraefikService. The differentiation between the two is specified in the Kind field.
   *
   * @schema TraefikServiceSpecMirroringMirrors#name
   */
  readonly name: string;

  /**
   * Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
   *
   * @schema TraefikServiceSpecMirroringMirrors#namespace
   */
  readonly namespace?: string;

  /**
   * NativeLB controls, when creating the load-balancer, whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP. The Kubernetes Service itself does load-balance to the pods. By default, NativeLB is false.
   *
   * @schema TraefikServiceSpecMirroringMirrors#nativeLB
   */
  readonly nativeLb?: boolean;

  /**
   * PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service. By default, passHostHeader is true.
   *
   * @schema TraefikServiceSpecMirroringMirrors#passHostHeader
   */
  readonly passHostHeader?: boolean;

  /**
   * Percent defines the part of the traffic to mirror. Supported values: 0 to 100.
   *
   * @schema TraefikServiceSpecMirroringMirrors#percent
   */
  readonly percent?: number;

  /**
   * Port defines the port of a Kubernetes Service. This can be a reference to a named port.
   *
   * @schema TraefikServiceSpecMirroringMirrors#port
   */
  readonly port?: TraefikServiceSpecMirroringMirrorsPort;

  /**
   * ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
   *
   * @schema TraefikServiceSpecMirroringMirrors#responseForwarding
   */
  readonly responseForwarding?: TraefikServiceSpecMirroringMirrorsResponseForwarding;

  /**
   * Scheme defines the scheme to use for the request to the upstream Kubernetes Service. It defaults to https when Kubernetes Service port is 443, http otherwise.
   *
   * @schema TraefikServiceSpecMirroringMirrors#scheme
   */
  readonly scheme?: string;

  /**
   * ServersTransport defines the name of ServersTransport resource to use. It allows to configure the transport between Traefik and your servers. Can only be used on a Kubernetes Service.
   *
   * @schema TraefikServiceSpecMirroringMirrors#serversTransport
   */
  readonly serversTransport?: string;

  /**
   * Sticky defines the sticky sessions configuration. More info: https://doc.traefik.io/traefik/v2.10/routing/services/#sticky-sessions
   *
   * @schema TraefikServiceSpecMirroringMirrors#sticky
   */
  readonly sticky?: TraefikServiceSpecMirroringMirrorsSticky;

  /**
   * Strategy defines the load balancing strategy between the servers. RoundRobin is the only supported value at the moment.
   *
   * @schema TraefikServiceSpecMirroringMirrors#strategy
   */
  readonly strategy?: string;

  /**
   * Weight defines the weight and should only be specified when Name references a TraefikService object (and to be precise, one that embeds a Weighted Round Robin).
   *
   * @schema TraefikServiceSpecMirroringMirrors#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'TraefikServiceSpecMirroringMirrors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecMirroringMirrors(obj: TraefikServiceSpecMirroringMirrors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'nativeLB': obj.nativeLb,
    'passHostHeader': obj.passHostHeader,
    'percent': obj.percent,
    'port': obj.port?.value,
    'responseForwarding': toJson_TraefikServiceSpecMirroringMirrorsResponseForwarding(obj.responseForwarding),
    'scheme': obj.scheme,
    'serversTransport': obj.serversTransport,
    'sticky': toJson_TraefikServiceSpecMirroringMirrorsSticky(obj.sticky),
    'strategy': obj.strategy,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Port defines the port of a Kubernetes Service. This can be a reference to a named port.
 *
 * @schema TraefikServiceSpecMirroringPort
 */
export class TraefikServiceSpecMirroringPort {
  public static fromNumber(value: number): TraefikServiceSpecMirroringPort {
    return new TraefikServiceSpecMirroringPort(value);
  }
  public static fromString(value: string): TraefikServiceSpecMirroringPort {
    return new TraefikServiceSpecMirroringPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
 *
 * @schema TraefikServiceSpecMirroringResponseForwarding
 */
export interface TraefikServiceSpecMirroringResponseForwarding {
  /**
   * FlushInterval defines the interval, in milliseconds, in between flushes to the client while copying the response body. A negative value means to flush immediately after each write to the client. This configuration is ignored when ReverseProxy recognizes a response as a streaming response; for such responses, writes are flushed to the client immediately. Default: 100ms
   *
   * @schema TraefikServiceSpecMirroringResponseForwarding#flushInterval
   */
  readonly flushInterval?: string;

}

/**
 * Converts an object of type 'TraefikServiceSpecMirroringResponseForwarding' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecMirroringResponseForwarding(obj: TraefikServiceSpecMirroringResponseForwarding | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'flushInterval': obj.flushInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sticky defines the sticky sessions configuration. More info: https://doc.traefik.io/traefik/v2.10/routing/services/#sticky-sessions
 *
 * @schema TraefikServiceSpecMirroringSticky
 */
export interface TraefikServiceSpecMirroringSticky {
  /**
   * Cookie defines the sticky cookie configuration.
   *
   * @schema TraefikServiceSpecMirroringSticky#cookie
   */
  readonly cookie?: TraefikServiceSpecMirroringStickyCookie;

}

/**
 * Converts an object of type 'TraefikServiceSpecMirroringSticky' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecMirroringSticky(obj: TraefikServiceSpecMirroringSticky | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_TraefikServiceSpecMirroringStickyCookie(obj.cookie),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Service defines an upstream HTTP service to proxy traffic to.
 *
 * @schema TraefikServiceSpecWeightedServices
 */
export interface TraefikServiceSpecWeightedServices {
  /**
   * Kind defines the kind of the Service.
   *
   * @schema TraefikServiceSpecWeightedServices#kind
   */
  readonly kind?: TraefikServiceSpecWeightedServicesKind;

  /**
   * Name defines the name of the referenced Kubernetes Service or TraefikService. The differentiation between the two is specified in the Kind field.
   *
   * @schema TraefikServiceSpecWeightedServices#name
   */
  readonly name: string;

  /**
   * Namespace defines the namespace of the referenced Kubernetes Service or TraefikService.
   *
   * @schema TraefikServiceSpecWeightedServices#namespace
   */
  readonly namespace?: string;

  /**
   * NativeLB controls, when creating the load-balancer, whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP. The Kubernetes Service itself does load-balance to the pods. By default, NativeLB is false.
   *
   * @schema TraefikServiceSpecWeightedServices#nativeLB
   */
  readonly nativeLb?: boolean;

  /**
   * PassHostHeader defines whether the client Host header is forwarded to the upstream Kubernetes Service. By default, passHostHeader is true.
   *
   * @schema TraefikServiceSpecWeightedServices#passHostHeader
   */
  readonly passHostHeader?: boolean;

  /**
   * Port defines the port of a Kubernetes Service. This can be a reference to a named port.
   *
   * @schema TraefikServiceSpecWeightedServices#port
   */
  readonly port?: TraefikServiceSpecWeightedServicesPort;

  /**
   * ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
   *
   * @schema TraefikServiceSpecWeightedServices#responseForwarding
   */
  readonly responseForwarding?: TraefikServiceSpecWeightedServicesResponseForwarding;

  /**
   * Scheme defines the scheme to use for the request to the upstream Kubernetes Service. It defaults to https when Kubernetes Service port is 443, http otherwise.
   *
   * @schema TraefikServiceSpecWeightedServices#scheme
   */
  readonly scheme?: string;

  /**
   * ServersTransport defines the name of ServersTransport resource to use. It allows to configure the transport between Traefik and your servers. Can only be used on a Kubernetes Service.
   *
   * @schema TraefikServiceSpecWeightedServices#serversTransport
   */
  readonly serversTransport?: string;

  /**
   * Sticky defines the sticky sessions configuration. More info: https://doc.traefik.io/traefik/v2.10/routing/services/#sticky-sessions
   *
   * @schema TraefikServiceSpecWeightedServices#sticky
   */
  readonly sticky?: TraefikServiceSpecWeightedServicesSticky;

  /**
   * Strategy defines the load balancing strategy between the servers. RoundRobin is the only supported value at the moment.
   *
   * @schema TraefikServiceSpecWeightedServices#strategy
   */
  readonly strategy?: string;

  /**
   * Weight defines the weight and should only be specified when Name references a TraefikService object (and to be precise, one that embeds a Weighted Round Robin).
   *
   * @schema TraefikServiceSpecWeightedServices#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'TraefikServiceSpecWeightedServices' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecWeightedServices(obj: TraefikServiceSpecWeightedServices | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'nativeLB': obj.nativeLb,
    'passHostHeader': obj.passHostHeader,
    'port': obj.port?.value,
    'responseForwarding': toJson_TraefikServiceSpecWeightedServicesResponseForwarding(obj.responseForwarding),
    'scheme': obj.scheme,
    'serversTransport': obj.serversTransport,
    'sticky': toJson_TraefikServiceSpecWeightedServicesSticky(obj.sticky),
    'strategy': obj.strategy,
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sticky defines whether sticky sessions are enabled. More info: https://doc.traefik.io/traefik/v2.10/routing/providers/kubernetes-crd/#stickiness-and-load-balancing
 *
 * @schema TraefikServiceSpecWeightedSticky
 */
export interface TraefikServiceSpecWeightedSticky {
  /**
   * Cookie defines the sticky cookie configuration.
   *
   * @schema TraefikServiceSpecWeightedSticky#cookie
   */
  readonly cookie?: TraefikServiceSpecWeightedStickyCookie;

}

/**
 * Converts an object of type 'TraefikServiceSpecWeightedSticky' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecWeightedSticky(obj: TraefikServiceSpecWeightedSticky | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_TraefikServiceSpecWeightedStickyCookie(obj.cookie),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kind defines the kind of the Service.
 *
 * @schema TraefikServiceSpecMirroringMirrorsKind
 */
export enum TraefikServiceSpecMirroringMirrorsKind {
  /** Service */
  SERVICE = "Service",
  /** TraefikService */
  TRAEFIK_SERVICE = "TraefikService",
}

/**
 * Port defines the port of a Kubernetes Service. This can be a reference to a named port.
 *
 * @schema TraefikServiceSpecMirroringMirrorsPort
 */
export class TraefikServiceSpecMirroringMirrorsPort {
  public static fromNumber(value: number): TraefikServiceSpecMirroringMirrorsPort {
    return new TraefikServiceSpecMirroringMirrorsPort(value);
  }
  public static fromString(value: string): TraefikServiceSpecMirroringMirrorsPort {
    return new TraefikServiceSpecMirroringMirrorsPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
 *
 * @schema TraefikServiceSpecMirroringMirrorsResponseForwarding
 */
export interface TraefikServiceSpecMirroringMirrorsResponseForwarding {
  /**
   * FlushInterval defines the interval, in milliseconds, in between flushes to the client while copying the response body. A negative value means to flush immediately after each write to the client. This configuration is ignored when ReverseProxy recognizes a response as a streaming response; for such responses, writes are flushed to the client immediately. Default: 100ms
   *
   * @schema TraefikServiceSpecMirroringMirrorsResponseForwarding#flushInterval
   */
  readonly flushInterval?: string;

}

/**
 * Converts an object of type 'TraefikServiceSpecMirroringMirrorsResponseForwarding' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecMirroringMirrorsResponseForwarding(obj: TraefikServiceSpecMirroringMirrorsResponseForwarding | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'flushInterval': obj.flushInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sticky defines the sticky sessions configuration. More info: https://doc.traefik.io/traefik/v2.10/routing/services/#sticky-sessions
 *
 * @schema TraefikServiceSpecMirroringMirrorsSticky
 */
export interface TraefikServiceSpecMirroringMirrorsSticky {
  /**
   * Cookie defines the sticky cookie configuration.
   *
   * @schema TraefikServiceSpecMirroringMirrorsSticky#cookie
   */
  readonly cookie?: TraefikServiceSpecMirroringMirrorsStickyCookie;

}

/**
 * Converts an object of type 'TraefikServiceSpecMirroringMirrorsSticky' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecMirroringMirrorsSticky(obj: TraefikServiceSpecMirroringMirrorsSticky | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_TraefikServiceSpecMirroringMirrorsStickyCookie(obj.cookie),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cookie defines the sticky cookie configuration.
 *
 * @schema TraefikServiceSpecMirroringStickyCookie
 */
export interface TraefikServiceSpecMirroringStickyCookie {
  /**
   * HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
   *
   * @schema TraefikServiceSpecMirroringStickyCookie#httpOnly
   */
  readonly httpOnly?: boolean;

  /**
   * Name defines the Cookie name.
   *
   * @schema TraefikServiceSpecMirroringStickyCookie#name
   */
  readonly name?: string;

  /**
   * SameSite defines the same site policy. More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
   *
   * @schema TraefikServiceSpecMirroringStickyCookie#sameSite
   */
  readonly sameSite?: string;

  /**
   * Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
   *
   * @schema TraefikServiceSpecMirroringStickyCookie#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'TraefikServiceSpecMirroringStickyCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecMirroringStickyCookie(obj: TraefikServiceSpecMirroringStickyCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpOnly': obj.httpOnly,
    'name': obj.name,
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Kind defines the kind of the Service.
 *
 * @schema TraefikServiceSpecWeightedServicesKind
 */
export enum TraefikServiceSpecWeightedServicesKind {
  /** Service */
  SERVICE = "Service",
  /** TraefikService */
  TRAEFIK_SERVICE = "TraefikService",
}

/**
 * Port defines the port of a Kubernetes Service. This can be a reference to a named port.
 *
 * @schema TraefikServiceSpecWeightedServicesPort
 */
export class TraefikServiceSpecWeightedServicesPort {
  public static fromNumber(value: number): TraefikServiceSpecWeightedServicesPort {
    return new TraefikServiceSpecWeightedServicesPort(value);
  }
  public static fromString(value: string): TraefikServiceSpecWeightedServicesPort {
    return new TraefikServiceSpecWeightedServicesPort(value);
  }
  private constructor(public readonly value: number | string) {
  }
}

/**
 * ResponseForwarding defines how Traefik forwards the response from the upstream Kubernetes Service to the client.
 *
 * @schema TraefikServiceSpecWeightedServicesResponseForwarding
 */
export interface TraefikServiceSpecWeightedServicesResponseForwarding {
  /**
   * FlushInterval defines the interval, in milliseconds, in between flushes to the client while copying the response body. A negative value means to flush immediately after each write to the client. This configuration is ignored when ReverseProxy recognizes a response as a streaming response; for such responses, writes are flushed to the client immediately. Default: 100ms
   *
   * @schema TraefikServiceSpecWeightedServicesResponseForwarding#flushInterval
   */
  readonly flushInterval?: string;

}

/**
 * Converts an object of type 'TraefikServiceSpecWeightedServicesResponseForwarding' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecWeightedServicesResponseForwarding(obj: TraefikServiceSpecWeightedServicesResponseForwarding | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'flushInterval': obj.flushInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Sticky defines the sticky sessions configuration. More info: https://doc.traefik.io/traefik/v2.10/routing/services/#sticky-sessions
 *
 * @schema TraefikServiceSpecWeightedServicesSticky
 */
export interface TraefikServiceSpecWeightedServicesSticky {
  /**
   * Cookie defines the sticky cookie configuration.
   *
   * @schema TraefikServiceSpecWeightedServicesSticky#cookie
   */
  readonly cookie?: TraefikServiceSpecWeightedServicesStickyCookie;

}

/**
 * Converts an object of type 'TraefikServiceSpecWeightedServicesSticky' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecWeightedServicesSticky(obj: TraefikServiceSpecWeightedServicesSticky | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cookie': toJson_TraefikServiceSpecWeightedServicesStickyCookie(obj.cookie),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cookie defines the sticky cookie configuration.
 *
 * @schema TraefikServiceSpecWeightedStickyCookie
 */
export interface TraefikServiceSpecWeightedStickyCookie {
  /**
   * HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
   *
   * @schema TraefikServiceSpecWeightedStickyCookie#httpOnly
   */
  readonly httpOnly?: boolean;

  /**
   * Name defines the Cookie name.
   *
   * @schema TraefikServiceSpecWeightedStickyCookie#name
   */
  readonly name?: string;

  /**
   * SameSite defines the same site policy. More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
   *
   * @schema TraefikServiceSpecWeightedStickyCookie#sameSite
   */
  readonly sameSite?: string;

  /**
   * Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
   *
   * @schema TraefikServiceSpecWeightedStickyCookie#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'TraefikServiceSpecWeightedStickyCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecWeightedStickyCookie(obj: TraefikServiceSpecWeightedStickyCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpOnly': obj.httpOnly,
    'name': obj.name,
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cookie defines the sticky cookie configuration.
 *
 * @schema TraefikServiceSpecMirroringMirrorsStickyCookie
 */
export interface TraefikServiceSpecMirroringMirrorsStickyCookie {
  /**
   * HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
   *
   * @schema TraefikServiceSpecMirroringMirrorsStickyCookie#httpOnly
   */
  readonly httpOnly?: boolean;

  /**
   * Name defines the Cookie name.
   *
   * @schema TraefikServiceSpecMirroringMirrorsStickyCookie#name
   */
  readonly name?: string;

  /**
   * SameSite defines the same site policy. More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
   *
   * @schema TraefikServiceSpecMirroringMirrorsStickyCookie#sameSite
   */
  readonly sameSite?: string;

  /**
   * Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
   *
   * @schema TraefikServiceSpecMirroringMirrorsStickyCookie#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'TraefikServiceSpecMirroringMirrorsStickyCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecMirroringMirrorsStickyCookie(obj: TraefikServiceSpecMirroringMirrorsStickyCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpOnly': obj.httpOnly,
    'name': obj.name,
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Cookie defines the sticky cookie configuration.
 *
 * @schema TraefikServiceSpecWeightedServicesStickyCookie
 */
export interface TraefikServiceSpecWeightedServicesStickyCookie {
  /**
   * HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
   *
   * @schema TraefikServiceSpecWeightedServicesStickyCookie#httpOnly
   */
  readonly httpOnly?: boolean;

  /**
   * Name defines the Cookie name.
   *
   * @schema TraefikServiceSpecWeightedServicesStickyCookie#name
   */
  readonly name?: string;

  /**
   * SameSite defines the same site policy. More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
   *
   * @schema TraefikServiceSpecWeightedServicesStickyCookie#sameSite
   */
  readonly sameSite?: string;

  /**
   * Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
   *
   * @schema TraefikServiceSpecWeightedServicesStickyCookie#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'TraefikServiceSpecWeightedServicesStickyCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TraefikServiceSpecWeightedServicesStickyCookie(obj: TraefikServiceSpecWeightedServicesStickyCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'httpOnly': obj.httpOnly,
    'name': obj.name,
    'sameSite': obj.sameSite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

